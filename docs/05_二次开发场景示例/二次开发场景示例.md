# 5. äºŒæ¬¡å¼€å‘åœºæ™¯ç¤ºä¾‹

æœ¬ç« èŠ‚æä¾›å¸¸è§çš„äºŒæ¬¡å¼€å‘åœºæ™¯ç¤ºä¾‹ï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€Ÿä¸Šæ‰‹ Aura Alpha çš„å®šåˆ¶å¼€å‘ã€‚

---

## ğŸ“‘ ç›®å½•

- [åœºæ™¯ä¸€ï¼šè‡ªå®šä¹‰è¯­éŸ³äº¤äº’](#åœºæ™¯ä¸€è‡ªå®šä¹‰è¯­éŸ³äº¤äº’)
- [åœºæ™¯äºŒï¼šäººä½“è·Ÿéšæ§åˆ¶](#åœºæ™¯äºŒäººä½“è·Ÿéšæ§åˆ¶)
- [åœºæ™¯ä¸‰ï¼šè‡ªå®šä¹‰è¿åŠ¨æ§åˆ¶](#åœºæ™¯ä¸‰è‡ªå®šä¹‰è¿åŠ¨æ§åˆ¶)
- [åœºæ™¯å››ï¼šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†](#åœºæ™¯å››ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†)
- [åœºæ™¯äº”ï¼šå¤šèŠ‚ç‚¹ååŒ](#åœºæ™¯äº”å¤šèŠ‚ç‚¹ååŒ)
- [åœºæ™¯å…­ï¼šè‡ªå®šä¹‰æ˜¾ç¤ºæ•ˆæœ](#åœºæ™¯å…­è‡ªå®šä¹‰æ˜¾ç¤ºæ•ˆæœ)

---

## åœºæ™¯ä¸€ï¼šè‡ªå®šä¹‰è¯­éŸ³äº¤äº’

### éœ€æ±‚æè¿°

ç›‘å¬ AI çš„è¯­éŸ³è¯†åˆ«ç»“æœï¼Œæ ¹æ®ç‰¹å®šå…³é”®è¯è§¦å‘è‡ªå®šä¹‰åŠ¨ä½œã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
è‡ªå®šä¹‰è¯­éŸ³äº¤äº’ç¤ºä¾‹
ç›‘å¬ ASR ç»“æœï¼Œæ ¹æ®å…³é”®è¯è§¦å‘åŠ¨ä½œ
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist


class VoiceCommandNode(Node):
    def __init__(self):
        super().__init__('voice_command_node')

        # è®¢é˜… ASR è¯†åˆ«ç»“æœ
        self.asr_sub = self.create_subscription(
            String,
            '/audio_msg',
            self.asr_callback,
            10
        )

        # å‘å¸ƒé€Ÿåº¦æ§åˆ¶æŒ‡ä»¤
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # å…³é”®è¯æ˜ å°„
        self.commands = {
            'å‰è¿›': self.move_forward,
            'åé€€': self.move_backward,
            'å·¦è½¬': self.turn_left,
            'å³è½¬': self.turn_right,
            'åœæ­¢': self.stop,
            'è½¬åœˆ': self.spin,
        }

        self.get_logger().info('è¯­éŸ³å‘½ä»¤èŠ‚ç‚¹å·²å¯åŠ¨')

    def asr_callback(self, msg):
        text = msg.data
        self.get_logger().info(f'æ”¶åˆ°è¯­éŸ³: {text}')

        # æ£€æŸ¥å…³é”®è¯
        for keyword, action in self.commands.items():
            if keyword in text:
                self.get_logger().info(f'æ‰§è¡Œå‘½ä»¤: {keyword}')
                action()
                break

    def move_forward(self):
        msg = Twist()
        msg.linear.x = 0.3
        self.cmd_pub.publish(msg)
        self.get_logger().info('å‰è¿›')

    def move_backward(self):
        msg = Twist()
        msg.linear.x = -0.3
        self.cmd_pub.publish(msg)
        self.get_logger().info('åé€€')

    def turn_left(self):
        msg = Twist()
        msg.angular.z = 0.5
        self.cmd_pub.publish(msg)
        self.get_logger().info('å·¦è½¬')

    def turn_right(self):
        msg = Twist()
        msg.angular.z = -0.5
        self.cmd_pub.publish(msg)
        self.get_logger().info('å³è½¬')

    def stop(self):
        self.cmd_pub.publish(Twist())
        self.get_logger().info('åœæ­¢')

    def spin(self):
        """åŸåœ°æ—‹è½¬ä¸€åœˆ"""
        import time
        msg = Twist()
        msg.angular.z = 1.0
        self.cmd_pub.publish(msg)
        time.sleep(6.28)  # çº¦ä¸€åœˆ
        self.stop()


def main():
    rclpy.init()
    node = VoiceCommandNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### è¿è¡Œæ–¹å¼

```bash
# ç»ˆç«¯ 1ï¼šå¯åŠ¨ç³»ç»Ÿ
ros2 launch robot_bringup bringup.launch.py

# ç»ˆç«¯ 2ï¼šè¿è¡Œè‡ªå®šä¹‰èŠ‚ç‚¹
python3 voice_command_node.py
```

---

## åœºæ™¯äºŒï¼šäººä½“è·Ÿéšæ§åˆ¶

### éœ€æ±‚æè¿°

è®¢é˜…äººä½“æ£€æµ‹ç»“æœï¼Œå®ç°è‡ªå®šä¹‰çš„è·Ÿéšé€»è¾‘ã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
è‡ªå®šä¹‰äººä½“è·Ÿéšç¤ºä¾‹
æ ¹æ®äººä½“æ£€æµ‹ç»“æœæ§åˆ¶æœºå™¨äººè·Ÿéš
"""

import rclpy
from rclpy.node import Node
from ai_msgs.msg import PerceptionTargets
from geometry_msgs.msg import Twist


class CustomFollowNode(Node):
    def __init__(self):
        super().__init__('custom_follow_node')

        # å‚æ•°é…ç½®
        self.declare_parameter('linear_speed', 0.3)
        self.declare_parameter('angular_speed', 0.5)
        self.declare_parameter('target_distance', 0.4)  # ç›®æ ‡äººä½“å ç”»é¢æ¯”ä¾‹
        self.declare_parameter('dead_zone', 0.1)

        self.linear_speed = self.get_parameter('linear_speed').value
        self.angular_speed = self.get_parameter('angular_speed').value
        self.target_distance = self.get_parameter('target_distance').value
        self.dead_zone = self.get_parameter('dead_zone').value

        # è®¢é˜…äººä½“æ£€æµ‹ç»“æœ
        self.detection_sub = self.create_subscription(
            PerceptionTargets,
            '/hobot_mono2d_body_detection',
            self.detection_callback,
            10
        )

        # å‘å¸ƒé€Ÿåº¦æ§åˆ¶
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # å›¾åƒå°ºå¯¸ï¼ˆæ ¹æ®å®é™…ç›¸æœºé…ç½®ï¼‰
        self.image_width = 640
        self.image_height = 480

        self.get_logger().info('è‡ªå®šä¹‰è·ŸéšèŠ‚ç‚¹å·²å¯åŠ¨')

    def detection_callback(self, msg):
        if not msg.targets:
            # æ²¡æœ‰æ£€æµ‹åˆ°äººä½“ï¼Œåœæ­¢
            self.cmd_pub.publish(Twist())
            return

        # é€‰æ‹©æœ€å¤§çš„äººä½“ç›®æ ‡
        target = self.select_target(msg.targets)
        if target is None:
            return

        # è®¡ç®—æ§åˆ¶æŒ‡ä»¤
        cmd = self.calculate_control(target)
        self.cmd_pub.publish(cmd)

    def select_target(self, targets):
        """é€‰æ‹©é¢ç§¯æœ€å¤§çš„äººä½“ç›®æ ‡"""
        max_area = 0
        selected = None

        for target in targets:
            if target.type != 'body':
                continue

            for roi in target.rois:
                area = roi.rect.width * roi.rect.height
                if area > max_area:
                    max_area = area
                    selected = roi

        return selected

    def calculate_control(self, roi):
        """æ ¹æ®ç›®æ ‡ä½ç½®è®¡ç®—æ§åˆ¶æŒ‡ä»¤"""
        cmd = Twist()

        # è®¡ç®—ç›®æ ‡ä¸­å¿ƒçš„æ°´å¹³åç§»ï¼ˆ-0.5 åˆ° 0.5ï¼‰
        center_x = (roi.rect.x_offset + roi.rect.width / 2) / self.image_width
        offset_x = center_x - 0.5

        # è®¡ç®—ç›®æ ‡è·ç¦»ï¼ˆåŸºäºé«˜åº¦æ¯”ä¾‹ï¼‰
        height_ratio = roi.rect.height / self.image_height
        distance_error = self.target_distance - height_ratio

        # è§’é€Ÿåº¦æ§åˆ¶ï¼ˆè½¬å‘ï¼‰
        if abs(offset_x) > self.dead_zone:
            cmd.angular.z = -offset_x * self.angular_speed * 2

        # çº¿é€Ÿåº¦æ§åˆ¶ï¼ˆå‰è¿›/åé€€ï¼‰
        if abs(distance_error) > self.dead_zone:
            cmd.linear.x = distance_error * self.linear_speed * 2

        self.get_logger().debug(
            f'åç§»: {offset_x:.2f}, è·ç¦»è¯¯å·®: {distance_error:.2f}, '
            f'çº¿é€Ÿåº¦: {cmd.linear.x:.2f}, è§’é€Ÿåº¦: {cmd.angular.z:.2f}'
        )

        return cmd


def main():
    rclpy.init()
    node = CustomFollowNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### å‚æ•°è°ƒæ•´

```bash
# è¿è¡Œæ—¶è°ƒæ•´å‚æ•°
ros2 run your_package custom_follow_node \
    --ros-args \
    -p linear_speed:=0.4 \
    -p angular_speed:=0.6 \
    -p target_distance:=0.5
```

---

## åœºæ™¯ä¸‰ï¼šè‡ªå®šä¹‰è¿åŠ¨æ§åˆ¶

### éœ€æ±‚æè¿°

å®ç°é¢„è®¾çš„è¿åŠ¨è½¨è¿¹ï¼Œå¦‚ç”»åœ†ã€ç”»æ–¹å½¢ç­‰ã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
è‡ªå®šä¹‰è¿åŠ¨è½¨è¿¹ç¤ºä¾‹
å®ç°é¢„è®¾çš„è¿åŠ¨æ¨¡å¼
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import math
import time


class MotionPatternNode(Node):
    def __init__(self):
        super().__init__('motion_pattern_node')

        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.timer = None

        self.get_logger().info('è¿åŠ¨è½¨è¿¹èŠ‚ç‚¹å·²å¯åŠ¨')

    def stop(self):
        """åœæ­¢è¿åŠ¨"""
        self.cmd_pub.publish(Twist())
        if self.timer:
            self.timer.cancel()

    def move_circle(self, radius=0.5, speed=0.2, clockwise=True):
        """
        ç”»åœ†è¿åŠ¨

        Args:
            radius: åœ†çš„åŠå¾„ï¼ˆç±³ï¼‰
            speed: çº¿é€Ÿåº¦ï¼ˆç±³/ç§’ï¼‰
            clockwise: æ˜¯å¦é¡ºæ—¶é’ˆ
        """
        self.get_logger().info(f'å¼€å§‹ç”»åœ†: åŠå¾„={radius}m, é€Ÿåº¦={speed}m/s')

        # è®¡ç®—è§’é€Ÿåº¦: v = Ï‰ Ã— r
        angular_speed = speed / radius
        if clockwise:
            angular_speed = -angular_speed

        # è®¡ç®—å®Œæˆä¸€åœˆæ‰€éœ€æ—¶é—´
        duration = 2 * math.pi * radius / speed

        msg = Twist()
        msg.linear.x = speed
        msg.angular.z = angular_speed

        start_time = time.time()
        rate = self.create_rate(50)

        while time.time() - start_time < duration:
            self.cmd_pub.publish(msg)
            rate.sleep()

        self.stop()
        self.get_logger().info('ç”»åœ†å®Œæˆ')

    def move_square(self, side_length=0.5, speed=0.2):
        """
        ç”»æ–¹å½¢è¿åŠ¨

        Args:
            side_length: è¾¹é•¿ï¼ˆç±³ï¼‰
            speed: çº¿é€Ÿåº¦ï¼ˆç±³/ç§’ï¼‰
        """
        self.get_logger().info(f'å¼€å§‹ç”»æ–¹å½¢: è¾¹é•¿={side_length}m')

        for i in range(4):
            # å‰è¿›ä¸€æ¡è¾¹
            self.move_straight(side_length, speed)
            time.sleep(0.5)

            # å³è½¬ 90 åº¦
            self.rotate(math.pi / 2, 0.5)
            time.sleep(0.5)

        self.get_logger().info('ç”»æ–¹å½¢å®Œæˆ')

    def move_straight(self, distance, speed):
        """ç›´çº¿è¿åŠ¨"""
        duration = distance / speed

        msg = Twist()
        msg.linear.x = speed

        start_time = time.time()
        rate = self.create_rate(50)

        while time.time() - start_time < duration:
            self.cmd_pub.publish(msg)
            rate.sleep()

        self.stop()

    def rotate(self, angle, angular_speed):
        """åŸåœ°æ—‹è½¬"""
        duration = abs(angle / angular_speed)

        msg = Twist()
        msg.angular.z = angular_speed if angle > 0 else -angular_speed

        start_time = time.time()
        rate = self.create_rate(50)

        while time.time() - start_time < duration:
            self.cmd_pub.publish(msg)
            rate.sleep()

        self.stop()

    def move_figure_eight(self, radius=0.3, speed=0.2):
        """
        ç”» 8 å­—å½¢è¿åŠ¨
        """
        self.get_logger().info('å¼€å§‹ç”» 8 å­—å½¢')

        # é¡ºæ—¶é’ˆåŠåœ†
        self.move_circle(radius, speed, clockwise=True)
        time.sleep(0.3)

        # é€†æ—¶é’ˆåŠåœ†
        self.move_circle(radius, speed, clockwise=False)

        self.get_logger().info('8 å­—å½¢å®Œæˆ')


def main():
    rclpy.init()
    node = MotionPatternNode()

    try:
        # ç¤ºä¾‹ï¼šç”»ä¸€ä¸ªåœ†
        node.move_circle(radius=0.5, speed=0.2)

        time.sleep(2)

        # ç¤ºä¾‹ï¼šç”»ä¸€ä¸ªæ–¹å½¢
        node.move_square(side_length=0.5, speed=0.2)

    except KeyboardInterrupt:
        node.stop()
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## åœºæ™¯å››ï¼šä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†

### éœ€æ±‚æè¿°

é‡‡é›† IMU å’Œç”µæ± æ•°æ®ï¼Œè¿›è¡Œè®°å½•æˆ–åˆ†æã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ç¤ºä¾‹
è®°å½• IMU å’Œç”µæ± æ•°æ®åˆ°æ–‡ä»¶
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu, BatteryState
from std_msgs.msg import Bool
import csv
import time
from datetime import datetime


class SensorLoggerNode(Node):
    def __init__(self):
        super().__init__('sensor_logger_node')

        # åˆ›å»ºæ—¥å¿—æ–‡ä»¶
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.imu_file = open(f'imu_log_{timestamp}.csv', 'w', newline='')
        self.battery_file = open(f'battery_log_{timestamp}.csv', 'w', newline='')

        self.imu_writer = csv.writer(self.imu_file)
        self.battery_writer = csv.writer(self.battery_file)

        # å†™å…¥è¡¨å¤´
        self.imu_writer.writerow([
            'timestamp', 'orientation_x', 'orientation_y', 'orientation_z', 'orientation_w',
            'angular_velocity_x', 'angular_velocity_y', 'angular_velocity_z',
            'linear_acceleration_x', 'linear_acceleration_y', 'linear_acceleration_z'
        ])
        self.battery_writer.writerow(['timestamp', 'voltage', 'percentage'])

        # è®¢é˜…ä¼ æ„Ÿå™¨è¯é¢˜
        self.imu_sub = self.create_subscription(
            Imu, '/imu/data', self.imu_callback, 10)

        self.battery_sub = self.create_subscription(
            BatteryState, '/battery_state', self.battery_callback, 10)

        self.connected_sub = self.create_subscription(
            Bool, '/motor/connected', self.connected_callback, 10)

        self.get_logger().info('ä¼ æ„Ÿå™¨è®°å½•èŠ‚ç‚¹å·²å¯åŠ¨')

    def imu_callback(self, msg):
        timestamp = time.time()
        self.imu_writer.writerow([
            timestamp,
            msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w,
            msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z,
            msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z
        ])

        # å®æ—¶æ˜¾ç¤º
        self.get_logger().debug(
            f'IMU: roll={msg.orientation.x:.3f}, '
            f'pitch={msg.orientation.y:.3f}, '
            f'yaw={msg.orientation.z:.3f}'
        )

    def battery_callback(self, msg):
        timestamp = time.time()
        self.battery_writer.writerow([
            timestamp, msg.voltage, msg.percentage
        ])

        self.get_logger().info(
            f'ç”µæ± : {msg.voltage:.2f}V, {msg.percentage*100:.1f}%'
        )

    def connected_callback(self, msg):
        status = 'å·²è¿æ¥' if msg.data else 'å·²æ–­å¼€'
        self.get_logger().info(f'ç”µæœºä¸²å£: {status}')

    def destroy_node(self):
        self.imu_file.close()
        self.battery_file.close()
        self.get_logger().info('æ—¥å¿—æ–‡ä»¶å·²ä¿å­˜')
        super().destroy_node()


def main():
    rclpy.init()
    node = SensorLoggerNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### æ•°æ®åˆ†æç¤ºä¾‹

```python
#!/usr/bin/env python3
"""
ä¼ æ„Ÿå™¨æ•°æ®åˆ†æç¤ºä¾‹
"""

import pandas as pd
import matplotlib.pyplot as plt


def analyze_imu_data(filename):
    """åˆ†æ IMU æ•°æ®"""
    df = pd.read_csv(filename)

    # ç»˜åˆ¶å§¿æ€è§’å˜åŒ–
    fig, axes = plt.subplots(3, 1, figsize=(12, 8))

    axes[0].plot(df['timestamp'], df['orientation_x'], label='Roll')
    axes[0].set_ylabel('Roll')
    axes[0].legend()

    axes[1].plot(df['timestamp'], df['orientation_y'], label='Pitch')
    axes[1].set_ylabel('Pitch')
    axes[1].legend()

    axes[2].plot(df['timestamp'], df['orientation_z'], label='Yaw')
    axes[2].set_ylabel('Yaw')
    axes[2].set_xlabel('Time (s)')
    axes[2].legend()

    plt.tight_layout()
    plt.savefig('imu_analysis.png')
    plt.show()


def analyze_battery_data(filename):
    """åˆ†æç”µæ± æ•°æ®"""
    df = pd.read_csv(filename)

    fig, ax1 = plt.subplots(figsize=(10, 6))

    ax1.plot(df['timestamp'], df['voltage'], 'b-', label='Voltage')
    ax1.set_xlabel('Time (s)')
    ax1.set_ylabel('Voltage (V)', color='b')

    ax2 = ax1.twinx()
    ax2.plot(df['timestamp'], df['percentage'] * 100, 'r-', label='Percentage')
    ax2.set_ylabel('Percentage (%)', color='r')

    plt.title('Battery Status')
    plt.savefig('battery_analysis.png')
    plt.show()


if __name__ == '__main__':
    analyze_imu_data('imu_log_20240101_120000.csv')
    analyze_battery_data('battery_log_20240101_120000.csv')
```

---

## åœºæ™¯äº”ï¼šå¤šèŠ‚ç‚¹ååŒ

### éœ€æ±‚æè¿°

åˆ›å»ºä¸€ä¸ªåè°ƒèŠ‚ç‚¹ï¼Œæ ¹æ® AI çŠ¶æ€å’Œä¼ æ„Ÿå™¨æ•°æ®åšå‡ºç»¼åˆå†³ç­–ã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
å¤šèŠ‚ç‚¹ååŒç¤ºä¾‹
ç»¼åˆ AI çŠ¶æ€ã€ä¼ æ„Ÿå™¨æ•°æ®è¿›è¡Œå†³ç­–
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Bool
from sensor_msgs.msg import BatteryState
from geometry_msgs.msg import Twist


class CoordinatorNode(Node):
    def __init__(self):
        super().__init__('coordinator_node')

        # çŠ¶æ€å˜é‡
        self.ai_state = 'idle'
        self.battery_percentage = 1.0
        self.motor_connected = False
        self.is_emergency = False

        # è®¢é˜…å„ç§çŠ¶æ€
        self.ai_state_sub = self.create_subscription(
            String, '/ai/state', self.ai_state_callback, 10)

        self.battery_sub = self.create_subscription(
            BatteryState, '/battery_state', self.battery_callback, 10)

        self.motor_sub = self.create_subscription(
            Bool, '/motor/connected', self.motor_callback, 10)

        # å‘å¸ƒæ§åˆ¶æŒ‡ä»¤
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # å®šæ—¶æ£€æŸ¥çŠ¶æ€
        self.timer = self.create_timer(1.0, self.check_status)

        self.get_logger().info('åè°ƒèŠ‚ç‚¹å·²å¯åŠ¨')

    def ai_state_callback(self, msg):
        self.ai_state = msg.data

    def battery_callback(self, msg):
        self.battery_percentage = msg.percentage

        # ä½ç”µé‡è­¦å‘Š
        if self.battery_percentage < 0.2:
            self.get_logger().warn(f'ä½ç”µé‡è­¦å‘Š: {self.battery_percentage*100:.1f}%')

        # æä½ç”µé‡ï¼Œè¿›å…¥ç´§æ€¥æ¨¡å¼
        if self.battery_percentage < 0.1:
            self.enter_emergency_mode('ç”µé‡è¿‡ä½')

    def motor_callback(self, msg):
        self.motor_connected = msg.data
        if not self.motor_connected:
            self.get_logger().error('ç”µæœºè¿æ¥æ–­å¼€!')

    def check_status(self):
        """å®šæœŸæ£€æŸ¥ç³»ç»ŸçŠ¶æ€"""
        if self.is_emergency:
            return

        # æ£€æŸ¥ç”µæœºè¿æ¥
        if not self.motor_connected:
            self.get_logger().warn('ç­‰å¾…ç”µæœºé‡è¿...')
            return

        # æ ¹æ® AI çŠ¶æ€è°ƒæ•´è¡Œä¸º
        if self.ai_state == 'speaking':
            # è¯´è¯æ—¶åœæ­¢è¿åŠ¨ï¼Œé¿å…å™ªéŸ³
            self.cmd_pub.publish(Twist())

        # ä½ç”µé‡æ—¶é™åˆ¶é€Ÿåº¦
        if self.battery_percentage < 0.2:
            self.get_logger().info('ä½ç”µé‡æ¨¡å¼ï¼šé™åˆ¶æœ€å¤§é€Ÿåº¦')

    def enter_emergency_mode(self, reason):
        """è¿›å…¥ç´§æ€¥æ¨¡å¼"""
        self.is_emergency = True
        self.get_logger().error(f'è¿›å…¥ç´§æ€¥æ¨¡å¼: {reason}')

        # åœæ­¢æ‰€æœ‰è¿åŠ¨
        self.cmd_pub.publish(Twist())

    def exit_emergency_mode(self):
        """é€€å‡ºç´§æ€¥æ¨¡å¼"""
        self.is_emergency = False
        self.get_logger().info('é€€å‡ºç´§æ€¥æ¨¡å¼')


def main():
    rclpy.init()
    node = CoordinatorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## åœºæ™¯å…­ï¼šè‡ªå®šä¹‰æ˜¾ç¤ºæ•ˆæœ

### éœ€æ±‚æè¿°

æ ¹æ®è‡ªå®šä¹‰äº‹ä»¶åˆ‡æ¢æ˜¾ç¤ºå†…å®¹ã€‚

### å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
è‡ªå®šä¹‰æ˜¾ç¤ºæ§åˆ¶ç¤ºä¾‹
å‘å¸ƒè‡ªå®šä¹‰çŠ¶æ€æ§åˆ¶æ˜¾ç¤º
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String


class CustomDisplayNode(Node):
    def __init__(self):
        super().__init__('custom_display_node')

        # å‘å¸ƒ AI çŠ¶æ€ï¼ˆæ§åˆ¶æ˜¾ç¤ºï¼‰
        self.state_pub = self.create_publisher(String, '/ai/state', 10)

        # å‘å¸ƒæƒ…ç»ªçŠ¶æ€
        self.emotion_pub = self.create_publisher(String, '/ai/emotion', 10)

        self.get_logger().info('è‡ªå®šä¹‰æ˜¾ç¤ºèŠ‚ç‚¹å·²å¯åŠ¨')

    def set_state(self, state):
        """
        è®¾ç½®æ˜¾ç¤ºçŠ¶æ€

        Args:
            state: idle, listening, thinking, speaking, error
        """
        msg = String()
        msg.data = state
        self.state_pub.publish(msg)
        self.get_logger().info(f'è®¾ç½®çŠ¶æ€: {state}')

    def set_emotion(self, emotion):
        """
        è®¾ç½®æƒ…ç»ªçŠ¶æ€

        Args:
            emotion: neutral, happy, sad, angry, surprised
        """
        msg = String()
        msg.data = emotion
        self.emotion_pub.publish(msg)
        self.get_logger().info(f'è®¾ç½®æƒ…ç»ª: {emotion}')

    def play_sequence(self, sequence, interval=2.0):
        """
        æ’­æ”¾çŠ¶æ€åºåˆ—

        Args:
            sequence: çŠ¶æ€åˆ—è¡¨
            interval: æ¯ä¸ªçŠ¶æ€æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
        """
        import time
        for state in sequence:
            self.set_state(state)
            time.sleep(interval)


def main():
    rclpy.init()
    node = CustomDisplayNode()

    try:
        # ç¤ºä¾‹ï¼šæ’­æ”¾ä¸€ä¸ªçŠ¶æ€åºåˆ—
        sequence = ['idle', 'listening', 'thinking', 'speaking', 'idle']
        node.play_sequence(sequence, interval=3.0)

        # ç¤ºä¾‹ï¼šè®¾ç½®æƒ…ç»ª
        node.set_emotion('happy')

    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒé…ç½®

### åˆ›å»ºè‡ªå®šä¹‰åŒ…

```bash
# è¿›å…¥å·¥ä½œç©ºé—´
cd ~/robot_ws/workspace/src

# åˆ›å»º Python åŒ…
ros2 pkg create --build-type ament_python my_custom_pkg \
    --dependencies rclpy std_msgs geometry_msgs sensor_msgs ai_msgs

# ç¼–è¯‘
cd ~/robot_ws/workspace
colcon build --packages-select my_custom_pkg
source install/setup.bash
```

### åŒ…ç»“æ„

```
my_custom_pkg/
â”œâ”€â”€ my_custom_pkg/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ voice_command_node.py
â”‚   â”œâ”€â”€ custom_follow_node.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ config/
â”‚   â””â”€â”€ params.yaml
â”œâ”€â”€ launch/
â”‚   â””â”€â”€ my_launch.py
â”œâ”€â”€ package.xml
â”œâ”€â”€ setup.py
â””â”€â”€ setup.cfg
```

### Launch æ–‡ä»¶ç¤ºä¾‹

```python
# launch/my_launch.py
from launch import LaunchDescription
from launch_ros.actions import Node


def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_custom_pkg',
            executable='voice_command_node',
            name='voice_command',
            output='screen',
            parameters=[{
                'param1': 'value1',
            }]
        ),
    ])
```

---

## ğŸ“‹ å¸¸ç”¨å‘½ä»¤é€ŸæŸ¥

```bash
# æŸ¥çœ‹è¯é¢˜åˆ—è¡¨
ros2 topic list

# ç›‘æ§è¯é¢˜
ros2 topic echo /ai/state
ros2 topic echo /cmd_vel

# å‘å¸ƒæµ‹è¯•æ¶ˆæ¯
ros2 topic pub /cmd_vel geometry_msgs/Twist "{linear: {x: 0.2}, angular: {z: 0.0}}"

# æŸ¥çœ‹èŠ‚ç‚¹
ros2 node list
ros2 node info /motor_node

# æŸ¥çœ‹å‚æ•°
ros2 param list /motor_node
ros2 param get /motor_node wheel_base

# åŠ¨æ€ä¿®æ”¹å‚æ•°
ros2 param set /motor_node max_linear_speed 0.3
```
